#!/usr/bin/env sage

#  Copyright (C) 2010 Imperial College London and others.
#  
#  Please see the AUTHORS file in the main source directory for a full list
#  of copyright holders.
#
#  Gerard Gorman
#  Applied Modelling and Computation Group
#  Department of Earth Science and Engineering
#  Imperial College London
#
#  amcgsoftware@imperial.ac.uk
#  
#  This library is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation,
#  version 2.1 of the License.
#
#  This library is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#  USA

cxx_head ="""/*
 *    WARNING: Do not edit this file as it is automatically generated
 *             and may be overwritten. Instead, merge your changes into
 *             sage/functional.sage and execute make from there. You will
 *             need sage in your PATH for this to work. If you commit your
 *             changes then commit both sage/functional.sage and the
 *             generated files.
 *
 *    Copyright (C) 2010 Imperial College London and others.
 *    
 *    Please see the AUTHORS file in the main source directory for a full list
 *    of copyright holders.
 *
 *    Gerard Gorman
 *    Applied Modelling and Computation Group
 *    Department of Earth Science and Engineering
 *    Imperial College London
 *
 *    amcgsoftware@imperial.ac.uk
 *    
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation,
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 *    USA
 */
"""

from GenerateC import GenerateC

def generate_Lipnikov_2d():

    # Define triangle vertices
    x, y = var('x y') # the vertex position we are trying to optimise.
    x1, y1 = var('x1 y1')
    x2, y2 = var('x2 y2')
    
    # A quadric function has been fit to the metric tensors in the patch
    # around (x, y).
    P = vector(SR, 6, [y**2, x**2, x*y, y, x, 1])
    a = vector(SR, 6, [var('a0'), var('a1'), var('a2'), var('a3'), var('a4'), var('a5')])
    b = vector(SR, 6, [var('b0'), var('b1'), var('b2'), var('b3'), var('b4'), var('b5')])
    c = vector(SR, 6, [var('c0'), var('c1'), var('c2'), var('c3'), var('c4'), var('c5')])
    # This M for the patch is:
    # M = (m00 m01)
    #     (m01 m11)
    # where
    # m00 = P.dot_product(a)
    # m01 = P.dot_product(b)
    # m11 = P.dot_product(c)
    # M = matrix(SR, 2, 2, [m00, m01, m01, m11])
    
    # For element i:
    m00 = (P.dot_product(a) + var('m00_1') + var('m00_2'))/3
    m01 = (P.dot_product(b) + var('m01_1') + var('m01_2'))/3
    m11 = (P.dot_product(c) + var('m11_1') + var('m11_2'))/3
    M = matrix(SR, 2, 2, [m00, m01, m01, m11])
    
    # Define parameter in metric space.
    l0 = vector(SR, 2, [x1-x,    y1-y])
    l1 = vector(SR, 2, [x2-x1, y2-y1])
    l2 = vector(SR, 2, [x-x2,    y-y2])

    dl0 = sqrt((l0*M*l0.transpose()).get(0))
    dl1 = sqrt((l1*M*l1.transpose()).get(0))
    dl2 = sqrt((l2*M*l2.transpose()).get(0))
    
    l = dl0+dl1+dl2
    
    # Calculate area in metric space.
    a_m = sqrt(M.det())*matrix(SR, 2, 2, [x1-x, y1-y, x2-x, y2-y]).det()/2
    
    # f = min(l/3, 3/l)
    # However, cannot differentiate min(). Therefore, we choose a branch depending on the outcome of the min.
    f0 = l/3.0
    f1 = 3.0/l

    F0 = (f0 * (2.0 - f0))**3
    F1 = (f1 * (2.0 - f1))**3

    q0 = 12*sqrt(3)*a_m*F0/(l*l)
    dq0dx = diff(q0, x)
    dq0dy = diff(q0, y)
    
    q1 = 12*sqrt(3)*a_m*F1/(l*l)
    dq1dx = diff(q1, x)
    dq1dy = diff(q1, y)

    cxx_body = """  void grad_r(real_t x, real_t y,
              real_t a0, real_t a1, real_t a2, real_t a3, real_t a4, real_t a5,
              real_t b0, real_t b1, real_t b2, real_t b3, real_t b4, real_t b5,
              real_t c0, real_t c1, real_t c2, real_t c3, real_t c4, real_t c5,
              real_t x1, real_t y1, real_t m00_1, real_t m01_1, real_t m11_1,
              real_t x2, real_t y2, real_t m00_2, real_t m01_2, real_t m11_2,
              real_t *grad){
    real_t f0 = %s;
    real_t f1 = %s;
    if(f0<f1){
      grad[0] = %s;
      grad[1] = %s;
    }else{
      grad[0] = %s;
      grad[1] = %s;
    }

    return;
  }
"""%(GenerateC(str(f0)), GenerateC(str(f1)), GenerateC(str(dq0dx)), GenerateC(str(dq0dy)), GenerateC(str(dq1dx)), GenerateC(str(dq1dy)))

    f = open('../include/dqdx_2d.h', 'w')
    f.write(cxx_head)
    f.write(cxx_body)
    f.close()

def generate_Lipnikov2_2d():

    # Define triangle vertices
    x, y = var('x y') # the vertex position we are trying to optimise.
    x1, y1 = var('x1 y1')
    x2, y2 = var('x2 y2')
    
    # A quadric function has been fit to the metric tensors in the patch
    # around (x, y).
    P = vector(SR, 6, [y**2, x**2, x*y, y, x, 1])
    a = vector(SR, 6, [var('a0'), var('a1'), var('a2'), var('a3'), var('a4'), var('a5')])
    b = vector(SR, 6, [var('b0'), var('b1'), var('b2'), var('b3'), var('b4'), var('b5')])
    c = vector(SR, 6, [var('c0'), var('c1'), var('c2'), var('c3'), var('c4'), var('c5')])
    # This M for the patch is:
    # M = (m00 m01)
    #     (m01 m11)
    # where
    # m00 = P.dot_product(a)
    # m01 = P.dot_product(b)
    # m11 = P.dot_product(c)
    # M = matrix(SR, 2, 2, [m00, m01, m01, m11])
    
    # For element i:
    m00 = (P.dot_product(a) + var('m00_1') + var('m00_2'))/3
    m01 = (P.dot_product(b) + var('m01_1') + var('m01_2'))/3
    m11 = (P.dot_product(c) + var('m11_1') + var('m11_2'))/3
    M = matrix(SR, 2, 2, [m00, m01, m01, m11])
    
    # Define parameter in metric space.
    l0 = vector(SR, 2, [x1-x,    y1-y])
    l1 = vector(SR, 2, [x2-x1, y2-y1])
    l2 = vector(SR, 2, [x-x2,    y-y2])

    dl0 = sqrt((l0*M*l0.transpose()).get(0))
    dl1 = sqrt((l1*M*l1.transpose()).get(0))
    dl2 = sqrt((l2*M*l2.transpose()).get(0))
    
    l = dl0+dl1+dl2
    
    # Calculate area in metric space.
    a_m = sqrt(M.det())*matrix(SR, 2, 2, [x1-x, y1-y, x2-x, y2-y]).det()/2

    F = 1.63416547*3.83669838**3*(l/3)**-4*exp(-3.83669838/(l/3))/2
    F = 7.5854552/((l-1.5)**2 + 1.89199003)
    q = F*a_m
    
    dqdx = diff(q, x)
    dqdy = diff(q, y)

    cxx_body = """  void grad_r(real_t x, real_t y,
              real_t a0, real_t a1, real_t a2, real_t a3, real_t a4, real_t a5,
              real_t b0, real_t b1, real_t b2, real_t b3, real_t b4, real_t b5,
              real_t c0, real_t c1, real_t c2, real_t c3, real_t c4, real_t c5,
              real_t x1, real_t y1, real_t m00_1, real_t m01_1, real_t m11_1,
              real_t x2, real_t y2, real_t m00_2, real_t m01_2, real_t m11_2,
              real_t *grad){
    grad[0] = %s;
    grad[1] = %s;
    
    return;
  }
"""%(GenerateC(str(dqdx)), GenerateC(str(dqdy)))

    f = open('../include/dqdx_2d.h', 'w')
    f.write(cxx_head)
    f.write(cxx_body)
    f.close()

generate_Lipnikov2_2d()
